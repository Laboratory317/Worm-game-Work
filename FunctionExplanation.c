/*  < Turns() >
 * Функцията се разпорежда върху работата по изграждане на завой
 * Тя взема опашката и пренарежда блоковете чрез оператор FOR в съответната посока
 * Реализирани са 4 блока на пренареждане в посока:
    < по оста У:
        - нагоре
        - надолу
    >
    < по оста Х:
        - надясно
        - наляво
    >
 */
void Turns() {

    int i, j, difference; // тия се използват за for-овете, в променлива difference се попълва дължината от завой до завой

    // turns е масив в който се съхраняват кординатите на завоите, които прави
    for (i = turns0; i >= 0 && len < length; i--) {

        // ако този завой с координати по Х [...] e = предния завой с координати по Х [...]
        if (turns[i].x == turns[i - 1].x) {

            // взема се разстоянието между координатите по оста У между тези два завоя
            difference = turns[i].y - turns[i - 1].y;

            if (difference < 0) { // ако разтоянието е отрицателно( демек се движи надолу )
                for (j = 1; j <= (-difference); j++) { // правим модул |разликата| за да е положителна
                    // и въртим от j = 1  до колкото е разликата
                    // ( 1 понеже има поне едно иначе няма да има разлика )
                    tail[len].x = turns[i].x; // прави координатите( по Х ) на последното блокче от опашката да е равно на текущото блокче i
                    tail[len].y = turns[i].y + j; // прави координати на последното блокче ( по У ) да е равно на текущото блокче по y + J

                    gotoxy(tail[len].x, tail[len].y); // тук задава преместване до координати на последното блокче от опашката
                    printf("%c", 254); // и поставя символ - 254 ■ блокчето
                    len++;
                    // дължината нараства докато не е равно на дължинат на опашката
                    if (len == length)
                        break;
                }
            }
            else if (difference > 0) // ако разтоянието е положително ( демек се движи нагоре )
                for (j = 1; j <= difference; j++) {
                    tail[len].x = turns[i].x;
                    tail[len].y = turns[i].y - j; // единствената разлика с другото е че обръщаме чрез -

                    gotoxy(tail[len].x, tail[len].y);
                    printf("%c", 254);
                    len++;
                    if (len == length)
                        break;
                }
        }
        // ако този завой с координати по Y[...] е до предишния завой с координати по оста Y[...]
        else if (turns[i].y == turns[i - 1].y) {
            // взимаме разтоянието между двете точки където се намират завоите по оста Х
            difference = turns[i].x - turns[i - 1].x;

            if (difference < 0) { // ако разтоянието е отрицателно( демек се движи наляво )
                for (j = 1; j <= (-difference) && len < length; j++) {
                    tail[len].x = turns[i].x + j; // прибавяме J
                    tail[len].y = turns[i].y;
                    gotoxy(tail[len].x, tail[len].y);
                    printf("%c", 254);
                    len++;
                    if (len == length)
                        break;
                }
            }
            else if (difference > 0) { // ако разтоянието е положително ( демек се движи надясно )
                for (j = 1; j <= difference && len < length; j++) {
                    tail[len].x = turns[i].x - j; // изваждаме J
                    tail[len].y = turns[i].y;
                    gotoxy(tail[len].x, tail[len].y);
                    printf("%c", 254);
                    len++;
                    if (len == length)
                        break;
                }
            }

        }
    }
}
